{"body": "# helga\r\n\r\n[![Build Status](https://travis-ci.org/shaunduncan/helga.png)](https://travis-ci.org/shaunduncan/helga)\r\n\r\n\r\n## About\r\n\r\nAn python-based IRC bot using Twisted. Original inspiration came from [thepeopleseason/olga](https://github.com/thepeopleseason/olga).\r\nWhy re-implement another bot? Because olga is written in perl, and I wanted something a bit more sane to look at.\r\n\r\n\r\n## Requirements\r\n\r\nAll requirements for helga are listed in ``requirements.txt``. However, there is a single\r\nexternal requirement, and that is MongoDB. You don't need it, per se, but many of the included\r\nplugins use MongoDB for storing consistent state between restarts.\r\n\r\n\r\n## Getting Started\r\n\r\nStart by creating a virtualenv where helga will reside:\r\n\r\n    $ virtualenv helga\r\n    $ cd helga\r\n    $ source bin/activate\r\n\r\nThen grab the latest copy and install requirements:\r\n\r\n    $ git clone https://github.com/shaunduncan/helga src/helga\r\n    $ cd src/helga\r\n    $ python setup.py develop\r\n    $ pip install -r requirements.txt\r\n\r\nOnce you have performed the above steps, there will be a ``helga`` executable\r\nplaced in the ``bin`` dir of your virtualenv. Run helga by calling this:\r\n\r\n    $ /path/to/venv/bin/helga\r\n\r\nNote that this uses the default settings file, ``helga.settings`` to start. You can, and should, use\r\nyour own custom setttings. This file must a be an importable python file on $PYTHONPATH. To run helga\r\nwith your custom settings file, set an environment variable ``HELGA_SETTINGS`` to be a python import path:\r\n\r\n    $ export HELGA_SETTINGS=path.to.mysettings\r\n\r\nThis will preserve any defaults in ``helga.settings``, but you can override at will.\r\n\r\n### Local Development\r\n\r\nThe included Vagrantfile will let you spin up a VM to run both MongoDB and an IRC server\r\nfor local development. Once you've followed the previous instructions for installing helga,\r\nsimply ``vagrant up``. This will forward host ports 6667 (irc) and 27017 (mongo) to the guest.\r\nAt this point, simply runing ``helga`` from the command line will connect to this VM.\r\n\r\n\r\n## Plugins\r\n\r\n### Overview\r\n\r\nHelga supports plugins outside of the core source code. Plugins have a minimal API, but there\r\nare some basic rules that should be followed. All core plugin implementations can be found\r\nin ``helga.plugins.core``. The basic requirement for plugins is that they have a ``process``\r\nattribute that is a callable and determines if the plugin should handle a message, and\r\na ``run`` method that actually performs the legwork of what the plugin should do. By convention,\r\nthe ``process`` method should accept four arguments:\r\n\r\n- **client**: an instance of ``helga.comm.Client``\r\n- **channel**: the channel on which the message was received\r\n- **nick**: the current nick of the message sender\r\n- **message**: the message string itself\r\n\r\nThe ``run`` is a bit different as it is up to the plugin implementation itself to decide what\r\narguments are necessary to generate a response. This method should be called by ``process`` and\r\nshould return one of:\r\n\r\n- None or empty string, if no response is to be sent over IRC\r\n- Non-empty string for a single line response\r\n- List of strings for multiline responses\r\n\r\nReally, as long as you follow the above conventions, you can write plugins however you wish.\r\nHowever, you should try to keep plugins simple and use the included decorators ``command``,\r\n``match``, and ``preprocessor`` (explained later). However, if you prefer writing a plugin\r\nas a class, you can subclass the included ``Plugin`` base class, provided you have followed\r\nthe above rules. Here is a simple example:\r\n\r\n```python\r\nimport time\r\nfrom helga.plugins.core import Plugin\r\n\r\nclass MyPlugin(Plugin):\r\n    def run(self, channel, nick, message):\r\n        return 'Current timestamp: {0}'.format(time.time())\r\n\r\n    def process(self, channel, nick, message):\r\n        if message.startswith('!time'):\r\n            return self.run(channel, nick, message)\r\n```\r\n\r\n**NOTE** the previous example is not the preferred way. You should use the included\r\ndecorators instead (shown below).\r\n\r\n### Plugin Types\r\n\r\nFor the most part, there are two main types of plugins: commands and matches. Commands are plugins\r\nthat require a user to specifically ask for helga to perform some action. For example,\r\n``helga haiku`` or ``helga google something to search``. Matches are on the other hand are\r\nintended to be autoresponders that give some extra meaning or context to what a user has said.\r\nFor example, if helga matches for a string \"foo\":\r\n\r\n    <sduncan> i'm talking about foo in this message\r\n    <helga> sduncan is talking about foo\r\n\r\nFor the sake of simplicity, there are two convenient decorators for authoring these types\r\nof plugins (which is usually the case). For example:\r\n\r\n```python\r\nfrom helga.plugins import command, match\r\n\r\n@command('foo', aliases=['foobar'], help=\"The foo command\")\r\ndef foo(client, channel, nick, message, cmd, args):\r\n    # This is run on \"helga foo\" or \"helga foobar\"\r\n    return \"Running the foo command\"\r\n\r\n@match(r'bar')\r\ndef bar(client, channel, nick, message, matches):\r\n    # This will run whenever a user mentions the word 'bar'\r\n    return \"{0} said bar!\".format(nick)\r\n```\r\n\r\nYou may notice in the above example that each decorated function accepts different arguments.\r\nFor commands, there are two additional arguments ``cmd`` and ``args``. The former is the parsed\r\ncommand that was used to run the method (which could be \"foo\" in the above case, or the alias\r\n\"foobar\"). The latter is a list of whitespace delimited strings that follow the parsed commend.\r\nFor example ``helga foo a b c`` would mean the args param would be ``['a', 'b', 'c']``.\r\n\r\nFor the match plugin, the single additional argument is ``matches`` which is for the most part,\r\nthe result of ``re.findall``. However, the ``@match`` decorator accepts a callable in place of\r\na regex string. This callable should accept one argument: the message being processed. It should\r\nreturn a value that can be evaluated for truthiness and will be passed to the decorated function\r\nas the ``matches`` parameter.\r\n\r\n### Preprocessors\r\n\r\nPlugins can also be message preprocessors. These are callables that may perform some modification\r\non an incoming message prior to that message being delivered to any plugins. Preprocessors should\r\naccept arguments (in order) for ``client``, ``channel``, ``nick``, and ``message`` and should\r\nreturn a three-tuple consisting of (in order) ``channel``, ``nick``, and ``message``. To declare\r\na function as a preprocessor, a convenient decorator can be used:\r\n\r\n```python\r\nfrom helga.plugins import preprocessor\r\n\r\n@preprocessor\r\ndef blank_message(client, channel, nick, message):\r\n    return channel, nick, ''\r\n```\r\n\r\n### Complex plugins\r\n\r\nSome plugins do both matching and act as a command. For this reason, plugin decorators are chainable.\r\nHowever, remember that different plugin types expect decorated functions to accept different arguments.\r\nIt is best to accept ``*args`` for these:\r\n\r\n```python\r\nfrom helga.plugins import command, match, preprocessor\r\n\r\n@preprocessor\r\n@match(r'bar')\r\n@command('foo')\r\ndef complex(client, channel, nick, message, *args):\r\n    # len(args) == 0 for preprocessors\r\n    # len(args) == 1 for matches\r\n    # len(args) == 2 for commands\r\n```\r\n\r\n### Plugin Priorities\r\n\r\nYou can control the priority in which a plugin is run. Note though, that preprocessors will always\r\nrun first. A priority value should be an integer value. There are no limits or bounds for this value,\r\nbut know that a higher value will mean a higher priority. If you are writing ``Plugin`` subclass\r\nstyle plugins, you will need to set a ``priority`` attribute of your object. This is done automatically\r\nif you call ``super(MyClass, self).__init__(priority=some_value)`` in your class's ``__init__``.\r\n\r\nHowever, if you are using the preferred decorator style for writing plugins, you can supply a ``priority``\r\nkeyword argument to the decorator:\r\n\r\n```python\r\nfrom helga import command, match, preprocessor\r\n\r\n@preprocessor(priority=10)\r\ndef foo_preprocess(*args):\r\n    pass\r\n\r\n@command('foo', priority=20)\r\ndef foo_command(*args):\r\n    pass\r\n\r\n@match(r'foo', priority=30)\r\ndef foo_match(*args):\r\n    pass\r\n```\r\n\r\nFor convenience, there are constants that can be used for setting priorities:\r\n\r\n- **PRIORITY_LOW** = 25\r\n- **PRIORITY_NORMAL** = 50\r\n- **PRIORITY_HIGH** = 75\r\n\r\nAlso, each decorator/plugin type has its own default value for priority:\r\n\r\n- Preprocessors have default priority of ``PRIORITY_NORMAL``\r\n- Commands have default priority of ``PRIORITY_NORMAL``\r\n- Matches have default priority of ``PRIORITY_LOW``\r\n\r\n### Publishing plugins\r\n\r\nHelga uses setuptools entry points for plugin loading. Once you've written a plugin you wish to use,\r\nyou will need to make sure your python package's setup.py contains an entry_point under the group\r\nname ``helga_plugins``. For example:\r\n\r\n    entry_points = {\r\n        'helga_plugins': [\r\n            'plugin_name = mylib.mymodule:MyPluginClass',\r\n        ],\r\n    },\r\n\r\nNote that if you are using decorated function for a plugin, you will want to specify the method name\r\nfor your entry point, i.e. ``mylib.mymodule:myfn``.\r\n\r\n\r\n### Webhooks\r\n\r\nAs of helga version 1.3, there is an included plugin for exposing an HTTP server to support webhooks.\r\nThis might be useful if you need to have a public facing HTTP service that you would like to use to\r\nperform some sort of announcement on a particular channel. This is also very extensible and should allow\r\nyou to create new webhooks in a very similar way plugins are created. This plugin is enabled by default\r\nand requires two settings: ``WEBHOOKS_PORT`` and ``WEBHOOKS_CREDENTIALS``. The former is of course the\r\nport on which to run this service. The latter should be a list of tuples in the form of (username, password).\r\nThese are used to perform HTTP basic authentication on any webhook that requires it.\r\n\r\nWebhook plugins work by declaring routes. This will not only feel similar to helga's decorator style\r\nplugins, but it will also feel very similar to anyone who has used something like Flask. There are two\r\nprimary decorators you will need to get started: ``route``, which declares a function as a route endpoint,\r\nand ``authenticated``, which ensures that the route function cannot be called without proper HTTP basic\r\nauthentication. Both of these can be imported from ``helga.plugins.webhooks``. For example:\r\n\r\n```python\r\nfrom helga.plugins.webhooks import authenticated, route\r\n\r\n@route(r'/foo/(?P<id>[0-9]+)')\r\n@authenticated\r\ndef foo(request, irc_client, id):\r\n    # This will require auth\r\n    pass\r\n\r\n@route('/bar', methods=['POST'])\r\ndef bar(request, irc_client):\r\n    # This will not require auth, and will only accept POST\r\n    pass\r\n```\r\n\r\nNOTE: For authenticated routes, you MUST specify ``@authenticated`` as the first decorator. This may be\r\nchanged in the future.\r\n\r\nThe route decorator accepts two arguments: 1) a path regular expression and 2) an optional list of\r\nHTTP methods to accept. If you do not specify a list of HTTP methods, only GET requests will be served.\r\nAll regex paths must be named groups and they will be passed as keyword arguments.\r\n\r\nTo register a new webhook plugin, you must declare an entry_point much in the same way normal plugins\r\nare done. However, the entry_point group name is ``helga_webhooks``. For example:\r\n\r\n    entry_points = {\r\n        'helga_webhooks': [\r\n            'name = mylib.mymodule:myhook',\r\n        ],\r\n    },\r\n\r\nThe webhook plugin itself has some commands for IRC interaction: start/stop to control the running HTTP\r\nlistener, and routes, which will show all the route paths and the HTTP methods they accept.\r\n\r\n\r\n### Third Party Plugins\r\n\r\nHere are some plugins that have been written that you can use:\r\n\r\n| Plugin  | Description                                          | Link                                          |\r\n| ------- | ---------------------------------------------------- | --------------------------------------------- |\r\n| karma   | Dish out karma points to other people                | https://github.com/coddingtonbear/helga-karma |\r\n| excuses | Generate a response from http://developerexcuses.com | https://github.com/alfredodeza/helga-excuses  |\r\n| norris  | Generate Chuck Norris facts for users                | https://github.com/alfredodeza/helga-norris   |\r\n\r\nWritten a plugin? Send a pull request to be listed in the above table!\r\n\r\n\r\n## Tests\r\n\r\nAll tests are written to be run via ``tox``. To run the test suite, inside your virtualenv:\r\n\r\n    $ cd src/helga\r\n    $ tox\r\n\r\n## Contributing\r\n\r\nContributions are welcomed, as well as any bug reports! Please note that any pull request will be denied\r\nif tests run via tox do not pass\r\n\r\n## License\r\n\r\nCopyright (c) 2013 Shaun Duncan\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n", "google": "UA-49520582-2", "name": "Helga", "note": "Don't delete this file! It's used internally to help with page regeneration.", "tagline": "One IRC bot to rule them all"}
